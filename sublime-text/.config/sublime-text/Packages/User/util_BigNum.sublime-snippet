<snippet>
	<content><![CDATA[
struct BigNum {
  int len, sign;
  VI a;

  BigNum() : len(1), sign(1), a(VI(len, 0)) {}

  BigNum(string s) : len(SZ(s)), sign(1), a(VI(len)) {
    Rof(i, 0, len) a[len - 1 - i] = s[i] - '0';
  }

  BigNum(VI& a_) : len(SZ(a_)), sign(1), a(a_) {}

  BigNum(ll x) : BigNum(to_string(x)) {}

  bool operator<(const BigNum& rh) const {
    if (len != rh.len) return len < rh.len;

    Rof(i, 0, len) {
      if (a[i] != rh.a[i]) return a[i] < rh.a[i];
    }
    return false;
  }

  BigNum operator+(BigNum& rh) {
    if (*this < rh) return rh + *this;
    VI res;
    int t = 0, len1 = rh.len;

    For(i, 0, len) {
      t += a[i];
      if (i < len1) t += rh.a[i];
      res.pb(t % 10);
      t /= 10;
    }

    if (t) res.pb(t);
    return BigNum(res);
  }

  BigNum operator-(BigNum& rh) {
    if (*this < rh) {
      auto ans = rh - *this;
      ans.sign = -1;
      return ans;
    }

    int len1 = rh.len, t = 0;
    auto& b = rh.a;
    VI res;

    For(i, 0, len) {
      t = a[i] - t;
      if (i < len1) t -= b[i];
      res.pb((t + 10) % 10);
      t = (t < 0);
    }
    while (SZ(res) > 1 && res.back() == 0) res.pop_back();
    return BigNum(res);
  }

  BigNum operator*(BigNum& rh) {
    if (*this < rh) {
      return rh * *this;
    }

    int len1 = rh.len, t = 0;
    auto& b = rh.a;
    VI res(len + len1 + 1);

    For(j, 0, len1) {
      For(i, 0, len) {
        t += res[i + j] + a[i] * b[j];
        res[i + j] = t % 10;
        t /= 10;
      }
      if (t) {
        res[j + len] = t;
        t = 0;
      }
    }

    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return BigNum(res);
  }

  BigNum operator*(ll b) {
    VI res;
    ll t = 0;

    for (int i = 0; i < len || t; i++) {
      if (i < len) t += a[i] * b;
      res.pb(t % 10);
      t /= 10;
    }
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return BigNum(res);
  }

  BigNum operator/(ll b) {
    assert(b != 0);
    VI res;
    ll t = 0;

    Rof(i, 0, len) {
      t = t * 10 + a[i];
      res.pb(t / b);
      t %= b;
    }
    reverse(all(res));
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return BigNum(res);
  }
};

ostream& operator<<(ostream& os, BigNum& num) {
  if (num.sign < 0) os << '-';
  Rof(i, 0, num.len) { os << num.a[i]; }
  return os;
}
istream& operator>>(istream& is, BigNum& num) {
  string s;
  is >> s;
  num = BigNum(s);
  return is;
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>util_BigNum</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope>
</snippet>
